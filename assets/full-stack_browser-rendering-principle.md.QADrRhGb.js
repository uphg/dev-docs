import{_ as o}from"./chunks/plugin-vue_export-helper.x3n3nnut.js";import{x as d,A as l,B as e,S as s,C as r,D as i,z as n,E as p,v as a,F as c}from"./chunks/vue.6z6dcVl3.js";const h="/dev-docs/assets/async-vs-defer.fF5kBKwD.png",_="/dev-docs/assets/browser-rendering-principle-1.f1asw16y.webp",k=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"full-stack/browser-rendering-principle.md","filePath":"full-stack/browser-rendering-principle.md","lastUpdated":1690551438000}'),f={name:"full-stack/browser-rendering-principle.md"},E=r("h1",{id:"浏览器渲染原理",tabindex:"-1"},[i("浏览器渲染原理 "),r("a",{class:"header-anchor",href:"#浏览器渲染原理","aria-label":'Permalink to "浏览器渲染原理"'},"​")],-1),m=r("p",null,"浏览器渲染过程",-1),S=n('<h2 id="html-解析过程" tabindex="-1">HTML 解析过程 <a class="header-anchor" href="#html-解析过程" aria-label="Permalink to &quot;HTML 解析过程&quot;">​</a></h2><ul><li>下载 HTML</li><li>解析 HTML</li><li>下载 CSS</li><li>解析 CSS</li><li>下载 JS （在此时停止解析 HTML，也就是所谓的阻塞 HTML 渲染）</li><li>解析 JS（解析完成后继续渲染 HTML）</li></ul><p>CSS 的下载和执行会阻塞 JS 的执行，JS 的执行必须在 CSS 的下载和执行之后。这样 JS 才能获取到正确的 DOM 信息（例如元素高度）</p><h2 id="为什么解析-html-时要等待-js-下载并执行完毕才能继续解析" tabindex="-1">为什么解析 HTML 时要等待 JS 下载并执行完毕才能继续解析？ <a class="header-anchor" href="#为什么解析-html-时要等待-js-下载并执行完毕才能继续解析" aria-label="Permalink to &quot;为什么解析 HTML 时要等待 JS 下载并执行完毕才能继续解析？&quot;">​</a></h2><ul><li>JS 的执行为什么会阻塞 HTML 渲染：因为执行 JS 的过程可能会修改 DOM 树。</li><li>JS 的下载为什么会阻塞 HTML 渲染：因为过去的浏览器没有那么强大，所以只会在 看到 script 标签后才会去下载、解析，在这段时间都会被阻塞。</li><li>由于浏览器没有做额外的优化，就导致下载 JS 也会阻塞 HTML 解析（理论上可以不阻塞）。</li><li>总结：因为下载和执行会导致 DOM 树的修改。</li></ul><h2 id="script-async-和-defer-的区别" tabindex="-1">script async 和 defer 的区别 <a class="header-anchor" href="#script-async-和-defer-的区别" aria-label="Permalink to &quot;script async 和 defer 的区别&quot;">​</a></h2><ul><li>script defer 和 script async 都可以 让 JS 的下载和 HTML 解析可以同时进行。</li><li>script defer 可以保证 JS 的执行 是在 HTML 解析之后，DOM Ready 之前。</li><li>但 script async 的 JS 执行跟 DOM Ready 完全没有任何关联，script async 的 JS 下载完成就执行。</li><li>所以 script async 适合 JS 运行跟当前页面 DOM 毫无关系的内容（不会操作 DOM）。</li><li>且 script async 不保证 script 标签的先后执行顺序（请求到就执行），script defer 可以保证 script 标签的执行顺序。</li></ul><div class="info custom-block"><p class="custom-block-title">DOM Ready</p><p>DOM Ready 是指在文档对象模型 (DOM) 树形结构已经被构建完毕，且所有的DOM元素都已经可以被访问和操作时的一个状态。在此状态下，JavaScript代码可以安全地访问和操作DOM，而不会导致未定义的行为或错误。</p></div><p>参考来自 <a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noreferrer">async vs defer attributes</a> 的图示：</p><p><img src="'+h+'" alt=""></p><h2 id="页面渲染原理" tabindex="-1">页面渲染原理 <a class="header-anchor" href="#页面渲染原理" aria-label="Permalink to &quot;页面渲染原理&quot;">​</a></h2><p>浏览器渲染页面流程图</p>',12),u=n('<p>它的主要工作流程为</p><ul><li>DOM 和 CSSOM 树组合在一起形成渲染树。</li><li>渲染树只包含页面所需的节点。</li><li>布局：例如屏幕宽高、尺寸等</li><li>绘制：对元素颜色、阴影进行渲染</li><li>合成：把多层次的内容合并，比如两个叠加的 div 背景颜色不同，上面的就会覆盖下面的</li></ul><p>关于渲染树的合成图（参考自：<a href="https://web.dev/critical-rendering-path-render-tree-construction/" target="_blank" rel="noreferrer">Render-tree Construction, Layout, and Paint</a>）</p><p><img src="'+_+'" alt=""></p><h2 id="reflow-repaint" tabindex="-1">reflow &amp; repaint <a class="header-anchor" href="#reflow-repaint" aria-label="Permalink to &quot;reflow &amp; repaint&quot;">​</a></h2><ul><li>reflow（页面重新布局）：当你页面布局发生改变时，会进行 reflow（改变高度）</li><li>repaint（页面重新绘制）：当你改变了一个页面元素的颜色、阴影等</li><li>每次页面重新绘制/或重新布局都会造成重新合成</li></ul><p>这个网站记录了所有可能会造成重绘或重排的 CSS 属性：<a href="https://csstriggers.com/" target="_blank" rel="noreferrer">CSSTriggers</a></p>',7);function B(A,M,b,T,C,w){const t=p("Mermaid");return a(),d("div",null,[E,m,(a(),l(s,null,{default:e(()=>[c(t,{id:"mermaid-6",class:"mermaid",graph:"flowchart%20LR%0A%0AA(%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%B8%E5%BF%83)%20--%3E%20B(%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E)%0AB%20--%3E%20C(%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97)%0AB%20--%3E%20D(JS%E8%A7%A3%E9%87%8A%E5%99%A8)%0AB%20--%3E%20E(%E5%85%B6%E4%BB%96)%0A"})]),fallback:e(()=>[i(" Loading... ")]),_:1})),S,(a(),l(s,null,{default:e(()=>[c(t,{id:"mermaid-117",class:"mermaid",graph:"flowchart%20LR%0A%20%20a(DOM%20%E6%A0%91)%20%26%20b(CSS%20%E6%A0%91)%20--%3E%20c(%E6%B8%B2%E6%9F%93%E6%A0%91)%0A%20%20c%20--%3E%20d(%22%E5%B8%83%E5%B1%80%EF%BC%88Layout%EF%BC%89%22)%0A%20%20d%20--%3E%20e(%22%E7%BB%98%E5%88%B6%EF%BC%88Paint%EF%BC%89%22)%0A%20%20e%20--%3E%20f(%22%E5%90%88%E6%88%90%EF%BC%88Composite%EF%BC%89%22)%0A"})]),fallback:e(()=>[i(" Loading... ")]),_:1})),u])}const L=o(f,[["render",B]]);export{k as __pageData,L as default};
