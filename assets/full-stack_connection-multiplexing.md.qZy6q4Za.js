import{_ as p}from"./chunks/plugin-vue_export-helper.x3n3nnut.js";import{x as k,A as t,B as s,S as e,z as h,C as o,E as d,v as i,F as l,D as n}from"./chunks/vue.6z6dcVl3.js";const r="/dev-docs/assets/connection-multiplexing.33EM2vgt.png",T=JSON.parse('{"title":"什么是连接复用","description":"","frontmatter":{},"headers":[],"relativePath":"full-stack/connection-multiplexing.md","filePath":"full-stack/connection-multiplexing.md","lastUpdated":1690688515000}'),c={name:"full-stack/connection-multiplexing.md"},E=h(`<h1 id="什么是连接复用" tabindex="-1">什么是连接复用 <a class="header-anchor" href="#什么是连接复用" aria-label="Permalink to &quot;什么是连接复用&quot;">​</a></h1><h2 id="web-性能指标" tabindex="-1">Web 性能指标 <a class="header-anchor" href="#web-性能指标" aria-label="Permalink to &quot;Web 性能指标&quot;">​</a></h2><p>当用户打开页面后的性能指标可以参考以下内容</p><ul><li>有内容出现时</li><li><strong>DOM ready 事件发生时</strong></li><li>页面可交互时</li><li>onLoad 事件发生</li><li>动态资源加载完成</li></ul><h2 id="dns-预解析" tabindex="-1">DNS 预解析 <a class="header-anchor" href="#dns-预解析" aria-label="Permalink to &quot;DNS 预解析&quot;">​</a></h2><p>假设 index.html 中有以下内容</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://a.com/1.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://b.com/2.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>默认它们的执行步骤为</p>`,8),g=o("p",null,"上面的步骤必须等待前一步执行完成后再执行下一步，但其实 DNS 解析域名部分可以优化为同时进行，如下",-1),u=h(`<p>代码实现有两种方式。第一种是在 index.html 的 <code>&lt;head&gt;</code> 中添加以下内容（适合前端），如下</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://a.com/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://b.com/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>第二种是在响应头中添加以下内容（适合后端），如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Link: &lt;https://a.com/&gt;; rel=dns-prefetch, &lt;https://b.com/&gt;; rel=dns-prefetch</span></span></code></pre></div><h2 id="tcp-优化" tabindex="-1">TCP 优化 <a class="header-anchor" href="#tcp-优化" aria-label="Permalink to &quot;TCP 优化&quot;">​</a></h2><p>关于 TCP 的优化</p><h3 id="连接复用" tabindex="-1">连接复用 <a class="header-anchor" href="#连接复用" aria-label="Permalink to &quot;连接复用&quot;">​</a></h3><p>在请求头 &amp; 响应头的第二部分都添加以下内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Connection: keep-alive</span></span></code></pre></div><p>该方法可以让 TCP 连接复用，让 TCP 连接开启一次可以请求/响应多次。</p><p>其中，默认每次 HTTP 请求的间隔使用 KeepAlive 配置，如下</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KeepAlive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: timeout</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span></span></code></pre></div><p>上面的内容表示可以等待的间隔为 5 秒，每次 TCP 连接最多请求 100 次</p><p>虽然服务器端（响应头）和浏览器端（请求头）都可以配置上面的属性，但浏览器理论上以服务器的配置为主，因为只有服务器支持，浏览器的该配置才能生效（当然 IE6 除外）。</p><p>TCP 连接复用对 HTTP 版本的支持：HTTP 1.1 默认添加该功能，HTTP 1.0 需要手动添加上面的配置</p><h3 id="并发连接" tabindex="-1">并发连接 <a class="header-anchor" href="#并发连接" aria-label="Permalink to &quot;并发连接&quot;">​</a></h3><ul><li>上面的 TCP 连接复用，其实是串行的，这样一次只能发送一个请求，每次请求必须要等上一次请求完成。</li><li>但是其实可以添加并发请求，来优化请求，比如我们可以同时发送多个请求，假设同时发送了 6 个请求，这就叫并发连接。</li><li>并且并发连接可以和请求复用结合，当前 6 个请求完成后，我们可以继续复用前 6 个请求的 TCP 继续请求。</li></ul><p>如何在浏览器中体现？可以找一个请求为 HTTP 1.1 版本的网页打开控制台，查看它们的 Connection ID 是否为同一个，同一个表示连接复用，如下：</p><p><img src="`+r+'" alt=""></p><h3 id="管道化" tabindex="-1">管道化 <a class="header-anchor" href="#管道化" aria-label="Permalink to &quot;管道化&quot;">​</a></h3><p>管道化就是将上面的并发连接实现为一个 TCP 连接可以并发请求多次。但它有一个缺点，就是它的响应必须按照请求的顺序响应，也就是：如果我们按照顺序请求了 1.js、2.js、3.js 那么响应的时候，2.js 必须等待 1.js 响应完成后才能响应，3.js 也要等待 2.js 响应</p>',21);function m(C,y,F,_,b,A){const a=d("Mermaid");return i(),k("div",null,[E,(i(),t(e,null,{default:s(()=>[l(a,{id:"mermaid-46",class:"mermaid",graph:"flowchart%20LR%0A%0AA(%22DNS%20%E8%A7%A3%E6%9E%90%20a.com%EF%BC%88%E8%8E%B7%E5%8F%96%20IP%EF%BC%89%22)%20--%3E%20B(%E8%AF%B7%E6%B1%82%201.js)%0AB%20--%3E%20C(%22DNS%20%E8%A7%A3%E6%9E%90%20b.com%EF%BC%88%E8%8E%B7%E5%8F%96%20IP%EF%BC%89%22)%0AC%20--%3E%20D(%E8%AF%B7%E6%B1%82%202.js)%0A"})]),fallback:s(()=>[n(" Loading... ")]),_:1})),g,(i(),t(e,null,{default:s(()=>[l(a,{id:"mermaid-50",class:"mermaid",graph:"flowchart%20LR%0A%0AA(%22DNS%20%E5%90%8C%E6%97%B6%E8%A7%A3%E6%9E%90%20a.com%E3%80%81b.com%22)%20--%3E%20B(%E8%AF%B7%E6%B1%82%201.js)%0AB%20--%3E%20C(%E8%AF%B7%E6%B1%82%202.js)%0A"})]),fallback:s(()=>[n(" Loading... ")]),_:1})),u])}const f=p(c,[["render",m]]);export{T as __pageData,f as default};
