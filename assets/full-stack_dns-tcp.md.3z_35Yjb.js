import{_ as a}from"./chunks/plugin-vue_export-helper.x3n3nnut.js";import{x as t,v as e,z as o}from"./chunks/vue.6z6dcVl3.js";const l="/dev-docs/assets/dns-tcp-1.tNcGAJcM.jpg",s="/dev-docs/assets/http-1.xqfme01k.png",i="/dev-docs/assets/http-2.Q9OsGDd1.png",D=JSON.parse('{"title":"DNS 与 TCP","description":"","frontmatter":{},"headers":[],"relativePath":"full-stack/dns-tcp.md","filePath":"full-stack/dns-tcp.md","lastUpdated":1721183597000}'),r={name:"full-stack/dns-tcp.md"},n=o('<h1 id="dns-与-tcp" tabindex="-1">DNS 与 TCP <a class="header-anchor" href="#dns-与-tcp" aria-label="Permalink to &quot;DNS 与 TCP&quot;">​</a></h1><p><img src="'+l+'" alt=""></p><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><p>全称 Domain Name System（域名系统），你给它一个域名，它给你返回一个 IP。</p><h3 id="dns-访问流程" tabindex="-1">DNS 访问流程 <a class="header-anchor" href="#dns-访问流程" aria-label="Permalink to &quot;DNS 访问流程&quot;">​</a></h3><ol><li>当我们在浏览器输入一个域名，如 <a href="http://baidu.com" target="_blank" rel="noreferrer">baidu.com</a>。浏览器会先看自己有没有访问过 <a href="http://baidu.com" target="_blank" rel="noreferrer">baidu.com</a> 如果有，就把上一次的 IP 给你（缓存），如果没有，就去问操作系统。</li><li>操作系统也会先看自己有没有缓存，如果没有，再去问 ISP（服务商），这里操作的系统地址的可以根据 hosts 手动更改。</li><li>浏览器拿到 IP 后，就会建立 TCP 连接。</li></ol><h2 id="tcp-连接" tabindex="-1">TCP 连接 <a class="header-anchor" href="#tcp-连接" aria-label="Permalink to &quot;TCP 连接&quot;">​</a></h2><p>全称 Transmission Control Protocol（<strong>传输控制协议</strong>）。</p><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>在下文的描述中 A 代指客户端，B 代指服务器</p><ol><li>A 向 B 发送一个 同步 syn。</li><li>B 向 A 回复一个 ACK 知道，并发送一个同步 syn。</li><li>A 向 B 回复一个 ACK 知道。</li></ol><blockquote><p>syn 是同步的缩写（不是同步异步的同步，是同步信息的同步）</p></blockquote><blockquote><p>ACK 是 acknowledge（获悉）的缩写</p></blockquote><img class="w-100" src="'+s+'"><p><strong>为什么要有第三次连接？</strong></p><p>为了确定 A 可以回复（ACK），只有 A、B 都可以回复 TCP 连接才能建立成功</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><ol><li>A 对 B 说 FIN(X) 表示我说完了。</li><li>B 对 A 回复 ACK(X) 知道了。</li><li>B 对 A 说 FIN(Y) 我说完了。</li><li>A 对 B 说 ACK(Y) 知道了。</li></ol><blockquote><p>FIN（finish 结束）表示关闭连接</p></blockquote><img class="w-100" src="'+i+'"><p>当 A、S 将上面的信息都发送完后才会关闭</p><p><strong>为什么四次挥手中间两次不能合并？</strong></p><p>两次回复的中间可能还会发送其他数据</p><h2 id="tcp-和-udp-的区别是什么" tabindex="-1">TCP 和 UDP 的区别是什么？ <a class="header-anchor" href="#tcp-和-udp-的区别是什么" aria-label="Permalink to &quot;TCP 和 UDP 的区别是什么？&quot;">​</a></h2><p>TCP（传输控制协议）和UDP（用户数据报协议）是网络通信中常用的两种传输协议。它们的区别如下：</p><ol><li>连接方式：TCP是面向连接的协议，而UDP是无连接的协议。TCP在传输数据前需要先建立连接，而UDP直接发送数据。</li><li>可靠性：TCP是可靠的传输协议，它保证数据的可靠传输，数据的丢失、重复、失序等问题都会被TCP协议处理。而UDP是不可靠的传输协议，数据传输过程中可能会有丢失、重复、失序等问题，但是UDP传输速度快，适合对数据可靠性要求不高的场景。</li><li>数据传输：TCP将数据分割成小的数据包进行传输，并且保证数据包的顺序，接收端可以按照顺序将数据包组合成完整的数据。UDP则将数据作为单个数据包进行传输，不保证顺序和完整性。</li><li>连接数：TCP支持一对一、一对多、多对一、多对多的连接，而UDP只支持一对一和一对多的连接。</li><li>流量控制：TCP有流量控制机制，可以根据网络状况动态调整传输速率，避免网络拥塞。UDP没有流量控制机制，会一直以最大速度发送数据，容易导致网络拥塞。</li></ol><p>总之，TCP适合对数据可靠性要求较高的场景，例如文件传输、电子邮件等；UDP适合对实时性要求较高、数据可靠性要求不高的场景，例如视频直播、语音通话等。</p><h2 id="tcp-面向连接有状态-udp-无状态" tabindex="-1">TCP 面向连接有状态，UDP 无状态？ <a class="header-anchor" href="#tcp-面向连接有状态-udp-无状态" aria-label="Permalink to &quot;TCP 面向连接有状态，UDP 无状态？&quot;">​</a></h2><p>TCP是面向连接的协议，建立连接后会在通信双方之间建立一个虚拟的通道，通信过程中会保持一定的状态信息，如序列号、确认号等。这些状态信息被用来保证数据传输的可靠性和顺序性。因此，TCP是有状态的协议。</p><p>相反，UDP是无连接的协议，不需要建立连接，也不需要保持连接状态。每个UDP数据包都是独立的，可以独立地发送和接收。UDP不会保证数据的可靠传输和顺序传输，也不会维护连接状态信息，因此是无状态的协议。</p><p>这种有状态和无状态的区别直接影响了TCP和UDP在网络通信中的应用场景。TCP适用于对数据可靠性要求较高的场景，如文件传输、电子邮件等；而UDP适用于对实时性要求较高的场景，如视频直播、语音通话等。</p>',31),c=[n];function p(d,P,h,u,_,m){return e(),t("div",null,c)}const b=a(r,[["render",p]]);export{D as __pageData,b as default};
