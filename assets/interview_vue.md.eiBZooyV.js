import{_ as e}from"./chunks/plugin-vue_export-helper.x3n3nnut.js";import{x as i,v as o,z as t}from"./chunks/vue.6z6dcVl3.js";const y=JSON.parse('{"title":"Vue 押题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue.md","filePath":"interview/vue.md","lastUpdated":1712497453000}'),a={name:"interview/vue.md"},l=t('<h1 id="vue-押题" tabindex="-1">Vue 押题 <a class="header-anchor" href="#vue-押题" aria-label="Permalink to &quot;Vue 押题&quot;">​</a></h1><h2 id="vue-2-生命周期有哪些" tabindex="-1">Vue 2 生命周期有哪些 <a class="header-anchor" href="#vue-2-生命周期有哪些" aria-label="Permalink to &quot;Vue 2 生命周期有哪些&quot;">​</a></h2><p>常用的</p><ul><li>beforeCreate（SSR）</li><li>created（SSR）</li><li>beforeMount</li><li>Mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>Destroyed</li></ul><p>特殊的</p><ul><li><strong><strong><a href="https://v2.cn.vuejs.org/v2/api/#activated" target="_blank" rel="noreferrer">activated</a></strong></strong>：keep-alive 缓存的组件激活时调用。</li><li><strong><strong><a href="https://v2.cn.vuejs.org/v2/api/#deactivated" target="_blank" rel="noreferrer">deactivated</a></strong></strong>：keep-alive 缓存的组件失活时调用。</li><li><a href="https://v2.cn.vuejs.org/v2/api/#errorCaptured" target="_blank" rel="noreferrer">errorCaptured</a>（<strong>2.5.0+</strong>）捕获来自任何后代组件的错误时调用。</li></ul><p>官方的一张图清晰的展示了生命周期</p><p><img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="lifecycle.png"></p><h2 id="vue-2-组件间通信方式有哪些" tabindex="-1">Vue 2 组件间通信方式有哪些 <a class="header-anchor" href="#vue-2-组件间通信方式有哪些" aria-label="Permalink to &quot;Vue 2 组件间通信方式有哪些&quot;">​</a></h2><ol><li>父子组件使用 props 和事件（on）进行通信</li><li>爷孙组件： <ol><li>使用 provide + inject 通信</li><li>嵌套使用父子组件通信（不推荐）</li></ol></li><li>任意组件（没有父子关系） <ol><li>使用 <code>event.$on</code> + <code>event.$emit</code>（$on 仅在 Vue 2 可用，缺点是多了会很乱，难以维护）</li><li>使用 Vuex 通信（Vue3 可以用 Pinia 代替 Vuex）</li></ol></li></ol><h2 id="vuex-是什么-主要用来干什么的" tabindex="-1">Vuex 是什么？主要用来干什么的？ <a class="header-anchor" href="#vuex-是什么-主要用来干什么的" aria-label="Permalink to &quot;Vuex 是什么？主要用来干什么的？&quot;">​</a></h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong><strong>状态管理模式</strong></strong>。它主要是为了解决在大型应用中的全局状态共享问题。</p><p>它包括以下几个 API：Store/State/Getter/Mutation/Action/Module</p><ol><li>Store 是一个容器，包含所有以下内容</li><li>State 用来存储应用程序状态</li><li>Getter 用来读取派生状态，基于 state 的计算属性。</li><li>Mutation 用于同步提交状态变更，是 Vuex 中唯一允许修改 state 的方式。</li><li>Action 用于异步变更状态，但它提交的是 mutation，而不是直接变更状态。</li><li>modules 用于将 store 分割为多个子模块，每个子模块拥有自己的 state、mutations、actions、getters 等。更好的管理和组织大型应用。</li></ol><p><strong>常见追问：Mutation 和 Action 为什么要分开？</strong></p><ul><li>为了让代码更易于维护。（但 Pinia 就把 Mutation 和 Action 合并了，所以并不如此）</li><li>mutations 用于同步操作，而 actions 用于异步操作。</li><li>此外，actions 可以包含任意的业务逻辑，而 mutations 应该保持功能单一性。</li></ul><h2 id="vuerouter-用过吗-怎么理解" tabindex="-1">VueRouter 用过吗？怎么理解？ <a class="header-anchor" href="#vuerouter-用过吗-怎么理解" aria-label="Permalink to &quot;VueRouter 用过吗？怎么理解？&quot;">​</a></h2><ol><li><p>背下文档第一句：Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成</p></li><li><p>它包括以下几个主要功能：<code>router-link</code> <code>router-view</code> 嵌套路由、History 模式、路由导航守卫、路由懒加载</p></li><li><p>Hash 模式和 History 模式的区别？</p><ol><li>Hash 模式使用 Hash 映射，一个用的 History API</li><li>Hash 不需要后端 nginx 配合，History 需要</li></ol></li><li><p>导航守卫如何实现登录控制？</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to是受控页面 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 没有登录) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li></ol><h2 id="vue-2-如何实现数据响应式" tabindex="-1">Vue 2 如何实现数据响应式 <a class="header-anchor" href="#vue-2-如何实现数据响应式" aria-label="Permalink to &quot;Vue 2 如何实现数据响应式&quot;">​</a></h2><ol><li>在 Vue2 中，通常使用 <code>v-model</code> 或 <code>.sync</code> 来实现数据响应式。其中，<code>v-model</code> 实际上是 <code>v-bind:value</code> 和 <code>v-on:input</code> 的语法糖。</li><li><code>v-bind:value</code> 通过使用 <code>Object.defineProperty</code> API 给 data 创建 getter 和 setter，实现了从 data ⇒ UI 的单向响应</li><li><code>v-on:input</code> 通过模板编译器向 DOM 添加事件监听器，以便在 DOM 触发 input 事件时修改 data，从而实现了从 UI ⇒ data 的单向响应</li><li>这两者结合起来就是数据响应式的实现方式</li></ol><h2 id="vue-3-为什么使用-proxy-代替-object-defineproperty" tabindex="-1">Vue 3 为什么使用 Proxy 代替 Object.defineProperty <a class="header-anchor" href="#vue-3-为什么使用-proxy-代替-object-defineproperty" aria-label="Permalink to &quot;Vue 3 为什么使用 Proxy 代替 Object.defineProperty&quot;">​</a></h2><h3 id="短答案" tabindex="-1">短答案 <a class="header-anchor" href="#短答案" aria-label="Permalink to &quot;短答案&quot;">​</a></h3><ol><li>Proxy 可以处理动态创建的 data 属性，无需像 Vue 2 一样使用 <code>Vue.set</code> ****来赋值</li><li>基于性能考虑，Vue 2 需要篡改数组的 7 个 API 实现数组响应，而 Vue 3 用 Proxy 不需要</li><li><code>Object.defineProperty</code> 需要提前递归遍历 data 做到响应式，而 Proxy 可以在真正用到深层数据的时候再做响应式（惰性的）</li></ol><h3 id="长答案" tabindex="-1">长答案 <a class="header-anchor" href="#长答案" aria-label="Permalink to &quot;长答案&quot;">​</a></h3><p>Vue2 数据响应式</p><ul><li>首先 Object.defineProperty 只支持对象读取，写入 代理：getter、setter。</li><li>通过数组的方法去更改数组或直接删除 data 数据，无法实现响应式，因为 Object.defineProperty 不支持。</li><li>因此 Vue2 中数组操作的 API 方法需要自己实现，例如 push、pop 等。</li><li>且由于无法监听到属性删除和新增，需要使用 Vue 实现的 API <code>Vue.detele</code>、<code>Vue.set</code> 完成。</li></ul><p>Vue3 数据响应式，使用 Proxy 实现，支持以下功能拦截</p><ul><li><code>get(target, propKey, receiver)</code>、<code>set(target, propKey, value, receiver)</code>。</li><li><code>has(target, propKey)</code>：拦截<code>propKey in proxy</code>。</li><li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.keys(proxy)</code>、<code>for...in</code> 循环、<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code> 等。</li><li><code>apply(target, object, args)</code>：拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li></ul><p><strong>所以，为什么 Vue3 使用 Proxy 代替 Object.defineProperty？</strong></p><ul><li>功能更强大：Proxy 比 Object.defineProperty 提供了更多的功能和灵活性。Proxy 可以拦截并自定义对象上的各种操作，包括属性访问、赋值、删除等。这意味着 Vue 3 可以更好地跟踪对象的变化，并能够提供更多的响应式行为。</li><li>更好的性能：与 Object.defineProperty 相比，Proxy 通常具有更高的性能。Proxy 在底层实现上能够更高效地拦截对象操作，因此在大多数情况下，Vue 3 使用 Proxy 可以获得更好的性能表现。</li><li>更好的错误检测：Proxy 提供了更好的错误检测和调试能力。当使用 Object.defineProperty 时，如果出现错误，通常很难追踪和诊断问题。而使用 Proxy，可以更容易地捕获和处理错误，提供更好的开发者体验。</li><li>更好的浏览器支持：Object.defineProperty 在某些旧版本的浏览器中存在兼容性问题。Proxy 是 ES6 的一部分，并且在现代浏览器中得到广泛支持，这使得 Vue 3 可以更好地适应多种浏览器环境。</li></ul><blockquote><p>总结：Vue 3 选择使用 Proxy 替代 Object.defineProperty 是为了提供更好的功能、性能和开发者体验，并且更好地适应现代浏览器环境。</p></blockquote><h2 id="vue-3-为什么使用-composition-api" tabindex="-1">Vue 3 为什么使用 Composition API <a class="header-anchor" href="#vue-3-为什么使用-composition-api" aria-label="Permalink to &quot;Vue 3 为什么使用 Composition API&quot;">​</a></h2><p>答案参考尤雨溪的博客：<a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noreferrer">Vue Function-based API RFC - 知乎 (zhihu.com)</a></p><p>使用 Composition API 主要用来替代 Vue 2 中的 mixins、高阶组件、extends 和 Renderless Components 等，它有以下优点：</p><ol><li>数据来源更清晰，不会出现模版中的数据来源不清晰的问题。</li><li>不会出现命名空间冲突的情况（mixin 很容易命名冲突）。</li><li>性能更好。</li><li>此外，Composition API 更适合 TypeScript 类型检查。</li></ol><h2 id="vue-3-对比-vue-2-做了哪些改动" tabindex="-1">Vue 3 对比 Vue 2 做了哪些改动？ <a class="header-anchor" href="#vue-3-对比-vue-2-做了哪些改动" aria-label="Permalink to &quot;Vue 3 对比 Vue 2 做了哪些改动？&quot;">​</a></h2><p>Vue 3 相对于 Vue 2，做了以下几个改动（记不住可以只记前5条）：</p><ol><li>使用 <code>Proxy</code> 代替 <code>Object.defineProperty</code> 实现响应式，提供更好的性能和更好的类型推断</li><li><code>v-model:value</code> 代替 Vue2 的 <code>v-model</code> 和 <code>.sync</code></li><li>组件允许多个根元素</li><li>新增 <code>Teleport</code> 组件</li><li>使用 <code>createApp()</code> 代替 <code>new Vue()</code></li><li><code>destroyed</code> 生命周期被改为 <code>unmounted</code> 了（它的 before 同理）</li><li>ref 属性支持函数（VNode 节点中的 ref）</li><li>改进了模板编译器和渲染器，现在支持静态提升和一些编译时优化，使渲染性能更好</li><li>全局 API 发生了变化，如 <strong><code>Vue.config</code></strong> 改为 <strong><code>app.config</code></strong>、<strong><code>Vue.directive</code></strong> 改为 <strong><code>app.directive</code></strong> 等</li><li>更好的 TypeScript 支持，包括更好的类型推断和更准确的类型定义。</li></ol><h2 id="vue2-vue3-中-v-if-与-v-for-的优先级" tabindex="-1">Vue2 &amp; Vue3 中 <code>v-if</code> 与 <code>v-for</code> 的优先级 <a class="header-anchor" href="#vue2-vue3-中-v-if-与-v-for-的优先级" aria-label="Permalink to &quot;Vue2 &amp; Vue3 中 `v-if` 与 `v-for` 的优先级&quot;">​</a></h2><ul><li><strong>在 Vue2 中：</strong> 当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。请查阅<a href="https://v2.cn.vuejs.org/v2/guide/list.html#v-for-object" target="_blank" rel="noreferrer">列表渲染指南</a>以获取详细信息。</li><li><strong>在 Vue3 中：</strong> 当 <code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。请查看<a href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-v-if" target="_blank" rel="noreferrer">列表渲染指南</a>获取更多细节。</li></ul>',40),r=[l];function s(n,d,p,c,h,u){return o(),i("div",null,r)}const v=e(a,[["render",s]]);export{y as __pageData,v as default};
