import{_ as i}from"./chunks/plugin-vue_export-helper.x3n3nnut.js";import{x as a,v as l,z as s}from"./chunks/vue.6z6dcVl3.js";const t="/dev-docs/assets/http-1.xqfme01k.png",e="/dev-docs/assets/http-2.Q9OsGDd1.png",S=JSON.parse('{"title":"HTTP 押题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/http.md","filePath":"interview/http.md","lastUpdated":1695738516000}'),o={name:"interview/http.md"},r=s('<h1 id="http-押题" tabindex="-1">HTTP 押题 <a class="header-anchor" href="#http-押题" aria-label="Permalink to &quot;HTTP 押题&quot;">​</a></h1><h2 id="dns-是什么" tabindex="-1">DNS 是什么？ <a class="header-anchor" href="#dns-是什么" aria-label="Permalink to &quot;DNS 是什么？&quot;">​</a></h2><p>全称 Domain Name System（域名系统），你给它一个域名，它给你返回一个 IP，浏览器拿到 IP 后，就会建立 TCP 连接。</p><h2 id="tcp-连接" tabindex="-1">TCP 连接 <a class="header-anchor" href="#tcp-连接" aria-label="Permalink to &quot;TCP 连接&quot;">​</a></h2><p>全称 Transmission Control Protocol（<strong>传输控制协议</strong>），一种计算机网络中的通信方式。</p><p>TCP 连接是指使用 TCP 协议在网络上建立的一种可靠的双向通信链路。TCP（Transmission Control Protocol/<strong>传输控制协议</strong>）是一种面向连接、可靠的传输层协议，常用于互联网上的数据传输。</p><p>TCP 连接的建立和维护是通过三次握手和四次挥手来完成的。在 TCP 连接建立之后，通信双方可以通过 TCP 协议进行数据的可靠传输。</p><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p><strong>三次握手是 TCP 协议用于建立可靠连接的过程</strong>，它确保了通信双方的发送和接收能力正常，以及双方的初始序列号（Sequence Number）的同步。下面是描述三次握手的过程：</p><ol><li><p>第一次握手（SYN）：</p><p>客户端向服务器发送一个标志位为SYN（Synchronize）的 TCP 报文段，表示客户端请求建立连接。这个报文段中包含了客户端的初始序列号（ISN）。</p></li><li><p>第二次握手（SYN + ACK）：</p><p>服务器收到客户端的 SYN 报文段后，会发送一个带有 ACK（Acknowledgment）和 SYN 标志位的 TCP 报文段作为回应。ACK 标志位表示确认客户端的 SYN 报文段，而 SYN 标志位表示服务器也请求建立连接。服务器会为自己选择一个初始序列号（ISN），并将其包含在报文段中。</p></li><li><p>第三次握手（ACK）：</p><p>客户端收到服务器的 SYN + ACK 报文段后，会发送一个带有 ACK 标志位的 TCP 报文段作为确认。这个报文段中的 ACK 字段值为服务器的初始序列号加1，表示客户端已经确认了服务器的请求，连接建立成功。</p></li></ol><p>此时，连接已经建立，双方都可以开始发送数据。</p><img class="w-100" src="'+t+'"><p><strong>为什么要有第三次连接？</strong></p><p>为了确定 A 可以回复（ACK），只有 A、B 都可以回复 TCP 连接才能建立成功。</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p><strong>TCP 的连接的关闭过程被称为&quot;四次挥手&quot;</strong>。下面是描述 HTTP 四次挥手的过程：</p><ol><li><p>客户端向服务器发送关闭连接请求：</p><p>客户端发送一个 TCP 报文段，其中设置了 FIN（Finish）标志位，表示客户端已经完成数据的发送，并请求关闭连接。此时，客户端进入&quot;半关闭&quot;状态，即只能发送数据，不能再接收数据。</p></li><li><p>服务器回复确认关闭请求：</p><p>服务器收到关闭请求后，发送一个带有 ACK（Acknowledgment）和 FIN 标志位的 TCP 报文段，表示服务器已经接受了关闭请求，并且也准备关闭连接。此时，服务器进入相同的&quot;半关闭&quot;状态。</p></li><li><p>服务器向客户端发送剩余的数据：</p><p>如果服务器还有未发送完的数据，它会继续发送数据给客户端。这些数据会被客户端接收和处理。</p></li><li><p>服务器发送关闭连接请求：</p><p>当服务器完成数据的发送后，它会发送一个带有 FIN 标志位的 TCP 报文段，表示服务器已经完成数据的发送，并请求关闭连接。</p></li><li><p>客户端回复确认关闭请求：</p><p>客户端收到服务器的关闭请求后，发送一个带有 ACK 标志位的 TCP 报文段，表示客户端已经接受了关闭请求，并且连接即将关闭。</p></li></ol><p>此时，连接正式关闭，双方都进入了&quot;关闭&quot;状态。双方都可以安全地关闭连接，并释放相关的资源。</p><img class="w-100" src="'+e+`"><p><strong>为什么四次挥手中间两次不能合并？</strong></p><p>两次回复的中间可能还会发送其他数据</p><h2 id="http-状态码是什么-有哪些" tabindex="-1">HTTP 状态码是什么，有哪些？ <a class="header-anchor" href="#http-状态码是什么-有哪些" aria-label="Permalink to &quot;HTTP 状态码是什么，有哪些？&quot;">​</a></h2><p>HTTP 状态码是由 Web 服务器发送给客户端的 3 位数字代码，它们指示所请求的网页的处理状态。以下是 HTTP 常用状态码：</p><ul><li>1xx（消息）：服务器已接收到请求，需要客户端继续操作才能完成请求。</li><li>2xx（成功）：服务器已成功处理请求。 <ul><li>200 OK：请求成功，返回的信息包含在响应中</li><li>201 Created：请求已经被成功处理，并创建了新的资源</li><li>204 No Content：请求已经被成功处理，但是返回的响应中没有实体的主体部分。</li></ul></li><li>3xx（重定向）：需要客户端执行额外的操作才能完成请求。 <ul><li>301 Moved Permanently（永久重定向）：请求的资源已经永久性地移动到新位置。</li><li>302 Found（暂时重定向）：请求的资源已经暂时性地移动到新位置。</li><li>304 Not Modified（未修改）：客户端请求的资源在上次请求后没有修改过，可以直接从缓存中取出。</li></ul></li><li>4xx（客户端错误）： <ul><li>400 Bad Request：表示客户端请求的语法错误，服务器无法理解；</li><li>401 Unauthorized：未认证，表示客户端未经认证，需要进行身份验证才能访问所请求的资源；</li><li>403 Forbidden：没有访问权限，表示服务器拒绝了请求，一般是因为客户端没有访问权限；</li><li>404 Not Found：表示所请求的资源不存在。</li></ul></li><li>5xx（服务器错误状态码）：服务器处理请求出错。 <ul><li>500 Internal Server Error：表示服务器内部错误，无法完成请求的处理。</li><li>503 Service Unavailable：暂停服务，表示服务器过载或维护，暂时无法处理请求。</li></ul></li></ul><h2 id="get-和-post-的区别有哪些" tabindex="-1">GET 和 POST 的区别有哪些？ <a class="header-anchor" href="#get-和-post-的区别有哪些" aria-label="Permalink to &quot;GET 和 POST 的区别有哪些？&quot;">​</a></h2><p><strong>区别一：幂等性</strong></p><ol><li>由于 GET 是读，POST 是写，所以 GET 是幂等的，POST 是不幂等的（幂等表示多次请求的结果一致）</li><li>所以用浏览器打开网页会发送 GET 请求，想要 POST 打开网页要用 form 标签</li><li>GET 打开的页面刷新是无害的，POST 打开的 页面刷新需要确认</li><li>GET 结果会被缓存，POST 结果不会被缓存</li><li>GET 打开的页面可被书签收藏，POST 打开的不行</li></ol><p><strong>区别二：请求参数</strong></p><ol><li>通常 GET 请求的参数放在 URL 里，POST 请求放在 body 消息体里（理论上 GET 请求也可以放在 body 里，POST 也可以放在 URL 里）</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息（其实 POST 放在消息体未做处理也不安全）</li><li>GET 请求参数放在 URL 里有长度限制，而 POST 放在 body 里没有长度限制（理论上都是有长度限制的，但是 POST 在 body 体中长度限制更宽泛）</li></ol><p><strong>区别三：TCP Packet</strong></p><ol><li>GET 产生一个 TCP 数据包，POST 产生两个或以上 TCP 数据包（由于）</li></ol><blockquote><p>根据技术规格文档，GET 和 POST 最大的区别是语义；但面试官一般问的是 实践过程中二者的区别，因此你需要了解服务器和浏览器对 GET 和 POST 的 常见实现方法。</p></blockquote><h2 id="http-缓存有哪些方案" tabindex="-1">HTTP 缓存有哪些方案 <a class="header-anchor" href="#http-缓存有哪些方案" aria-label="Permalink to &quot;HTTP 缓存有哪些方案&quot;">​</a></h2><ol><li>HTTP 1.1 强缓存：定义一个时间（毫秒数），在该时间内只用缓存的文件，并且把当前文件特征值记下。</li><li>HTTP 1.1 内容协商（弱缓存）：强缓存过期后，再次请求该文件时，附带特征值询问是否需要保留该文件（304 继续缓存，200 更新内容）。</li><li>如何在缓存未过期前更新内容： <ol><li>缓存的时间短一点</li><li>在URL中包含版本号或时间戳参数，以便客户端可以识别并请求最新的内容</li><li>强制刷新：在页面中添加一个手动刷新页面的按钮，在 JavaScript 中使用 <strong><code>location.reload()</code></strong> 可以绕过浏览器的缓存，从服务器获取最新的内容</li></ol></li><li>服务器处理请求：服务器接收到浏览器发送的HTTP请求后，会根据请求的内容进行处理。这可能涉及查询数据库、处理业务逻辑等操作。服务器生成HTTP响应，其中包含了请求的资源和其他相关信息。</li></ol><table><thead><tr><th></th><th>缓存（强缓存）</th><th>内容协商（弱缓存）</th></tr></thead><tbody><tr><td>HTTP 1.1</td><td>Cache-Control: max-age=3600<br>etag: ABC</td><td>If-Noe-Match: ABC<br>响应状态码：304 或 200</td></tr><tr><td>HTTP 1.0</td><td>Expires: Wed, 21 Oct 2015 02:30:00 GMT<br>Last-Modified: Wed, 21 Oct 2015 01:00:00 GMT</td><td>If-Modified-Since: Wed, 21 Oct 2015 01:00:00 GMT<br>响应状态码：304 或者 200</td></tr></tbody></table><h3 id="http-1-1" tabindex="-1">HTTP 1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP 1.1&quot;">​</a></h3><p>缓存（强缓存）</p><ul><li><code>cache-control: public, max-age=31536000</code> 表示缓存一年（一年内刷新页面都不会重新请求）</li><li><code>etag: ABC</code> 表示标记缓存的文件特征（MD5 哈希）</li></ul><p>内容协商（弱缓存）</p><ul><li><code>If-Noe-Match: ABC</code> 强缓存内容过期了，在请求时附带该字段，判断文件是否需要更新</li></ul><h3 id="http-1-0" tabindex="-1">HTTP 1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP 1.0&quot;">​</a></h3><p>缓存（强缓存）</p><ul><li><code>Expires: Wed, 21 Oct 2015 02:30:00</code> 表示 2015 年的8月21号 凌晨 2:30 过期（缺陷：用户系统时间可能不正确）</li><li><code>Last-Modified: Wed, 21 Oct 2015 01:00:00 GMT</code> 文件特征值，内容是最后一次更新的时间</li></ul><p>内容协商（弱缓存）</p><ul><li><code>If-Modified-Since: Wed, 21 Oct 2015 01:00:00</code> 表示指定时间更新的文件，是否需要缓存</li></ul><h2 id="http-和-https-的区别有哪些" tabindex="-1">HTTP 和 HTTPS 的区别有哪些？ <a class="header-anchor" href="#http-和-https-的区别有哪些" aria-label="Permalink to &quot;HTTP 和 HTTPS 的区别有哪些？&quot;">​</a></h2><blockquote><p>HTTPS = HTTP + SSL/TLS（安全层）</p></blockquote><h3 id="区别列表" tabindex="-1">区别列表 <a class="header-anchor" href="#区别列表" aria-label="Permalink to &quot;区别列表&quot;">​</a></h3><ol><li>HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。</li><li>HTTP 使用 80 端口，HTTPS 使用 443 端口。</li><li>HTTP 较快，HTTPS 较慢。</li><li>HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。</li></ol><p>HTTPS 的细节可以看网上的博客，比较复杂，难以记忆，建议写博客总结一下。</p><ul><li><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noreferrer">图解SSL/TLS协议</a></li><li><a href="https://juejin.cn/post/6844903892765900814" target="_blank" rel="noreferrer">HTTPS原理以及握手阶段</a></li></ul><h2 id="http-1-1-和-http-2-的区别有哪些" tabindex="-1">HTTP/1.1 和 HTTP/2 的区别有哪些？ <a class="header-anchor" href="#http-1-1-和-http-2-的区别有哪些" aria-label="Permalink to &quot;HTTP/1.1 和 HTTP/2 的区别有哪些？&quot;">​</a></h2><p>区别列表</p><ol><li>HTTP/2 使用了<strong>二进制传输</strong>，而且将 head 和 body 分成帧来传输；HTTP/1.1 是字符串传输。</li><li>HTTP/2 支持<strong>多路复用</strong>，HTTP/1.1 不支持。多路复用简单来说就是一个 TCP 连接 从单车道（不是单行道）变成了几百个双向通行的车道。</li><li>HTTP/2 可以<strong>压缩 head</strong>，但是 HTTP/1.1 不行（HTTP/2 采用了一种称为 HPACK 的压缩算法来压缩头部）</li><li>HTTP/2 支持<strong>服务器推送</strong>，但 HTTP/1.1 不支持。（实际上没多少人用）</li></ol><p>具体可以看我的课程《<a href="https://xiedaimala.com/courses/b65a6488-4038-4676-932e-ae125613ad69/random/b9497c3e82?#/common" target="_blank" rel="noreferrer">全面攻克 Web 性能优化</a>》</p><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><h3 id="同源策略是什么" tabindex="-1">同源策略是什么？ <a class="header-anchor" href="#同源策略是什么" aria-label="Permalink to &quot;同源策略是什么？&quot;">​</a></h3><p>如果两个 URL 的协议、端口和域名都完全一致，则这两个 URL 是同源</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//www.baidu.com:443/a</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//www.baidu.com:80/a</span></span></code></pre></div><h3 id="同源策略怎么做" tabindex="-1">同源策略怎么做？ <a class="header-anchor" href="#同源策略怎么做" aria-label="Permalink to &quot;同源策略怎么做？&quot;">​</a></h3><p>只要在<strong>浏览器</strong>里打开页面，就默认遵守同源策略。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>保证用户的隐私安全和数据安全</p><p>缺点</p><p>很多时候，前端需要访问另一个域名的后端接口，会被浏览器阻止其获取响应。</p><p>比如甲网站通过 AJAX 访问乙网站的 /money 查询余额，请求会发出，但是响应会被浏览器屏蔽</p><h3 id="怎么解决缺点" tabindex="-1">怎么解决缺点 <a class="header-anchor" href="#怎么解决缺点" aria-label="Permalink to &quot;怎么解决缺点&quot;">​</a></h3><p>使用跨域手段</p><ol><li>JSONP（前端体系课有完整且详细的介绍） <ol><li>甲站点利用 script 标签可以跨域的特性，向乙站点发送 get 请求。</li><li>乙站点后端改造 JS 文件的内容，将数据传进回调函数。</li><li>甲站点通过回调函数拿到乙站点的数据。</li></ol></li><li>CORS <ol><li><p>对于简单请求，乙站点在响应头里添加 <code>Access-Control-Allow-Origin:http://甲站点</code> 即可</p></li><li><p>对于复杂的请求，如 PATCH，乙站点需要：</p><p>响应 OPTIONS 请求，在响应中添加如下的响应头</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Access</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Allow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//甲站点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Access</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Allow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Methods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">POST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OPTIONS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PATCH</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Access</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Allow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Headers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Type</span></span></code></pre></div><p>响应 POST 请求，在响应中添加 <code>Access-Control-Allow-Origin</code> 头</p></li><li><p>如果需要附带身份信息，JS 中需要在 AJAX 里设置 <code>xhr.withCredentials = true</code></p></li></ol></li><li>Nginx 代理 / Node.js 代理 <ol><li>前端 ⇒ 后端 ⇒ 另一个域名的后端</li></ol></li></ol><p>详情参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noreferrer">MDN CORS 文档</a></p><h2 id="session、cookie、localstorage、sessionstorage-的区别" tabindex="-1">Session、Cookie、LocalStorage、SessionStorage 的区别 <a class="header-anchor" href="#session、cookie、localstorage、sessionstorage-的区别" aria-label="Permalink to &quot;Session、Cookie、LocalStorage、SessionStorage 的区别&quot;">​</a></h2><h3 id="cookie-v-s-localstorage" tabindex="-1">Cookie V.S. LocalStorage <a class="header-anchor" href="#cookie-v-s-localstorage" aria-label="Permalink to &quot;Cookie V.S. LocalStorage&quot;">​</a></h3><ol><li>主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会</li><li>Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）</li></ol><h3 id="localstorage-v-s-sessionstorage" tabindex="-1">LocalStorage V.S. SessionStorage <a class="header-anchor" href="#localstorage-v-s-sessionstorage" aria-label="Permalink to &quot;LocalStorage V.S. SessionStorage&quot;">​</a></h3><ol><li>LocalStorage 一般不会自动过期（除非用户手动清除）</li><li>SessionStorage 在回话结束时过期（如关闭浏览器之后，具体由浏览器自行决定）</li></ol><h3 id="cookie-v-s-session" tabindex="-1">Cookie V.S. Session <a class="header-anchor" href="#cookie-v-s-session" aria-label="Permalink to &quot;Cookie V.S. Session&quot;">​</a></h3><ol><li>Cookie 存在浏览器的文件里，Session 存在服务器的文件里</li><li>Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里</li></ol><h2 id="使用-http-发送一个请求的全流程" tabindex="-1">使用 HTTP 发送一个请求的全流程 <a class="header-anchor" href="#使用-http-发送一个请求的全流程" aria-label="Permalink to &quot;使用 HTTP 发送一个请求的全流程&quot;">​</a></h2><ol><li>DNS解析：当你输入一个域名时， <ol><li>浏览器会查看自己有没有缓存过网址的 IP</li><li>然后它会查看操作系统有没有域名对应的缓存 IP（hosts 文件）</li><li>然后才会去访问 ISP（移动、联通等服务商）</li></ol></li><li>建立 TCP 连接：然后浏览器根据 IP 与服务器建立 TCP 连接</li><li>发起HTTP请求：一旦TCP连接建立，浏览器会向服务器发送HTTP 请求。HTTP请求中包含了要访问的资源的类型（例如网页、图像或视频）以及其他附加信息，如请求方法（GET、POST等）和请求头部。</li><li>传输响应：服务器将生成的HTTP响应发送回浏览器。这个过程通过TCP连接进行，数据被分割成小的数据包并依次发送。</li><li>浏览器接收响应：浏览器接收到来自服务器的HTTP响应后，会对响应进行解析。解析后的响应包括响应状态码、响应头部和响应体。</li><li>渲染页面：如果响应的内容是一个HTML页面，浏览器会解析HTML代码，并加载其中的CSS和JavaScript等资源。浏览器使用解析后的数据构建DOM（文档对象模型）树，并将其呈现在用户界面上。</li><li>关闭连接：一旦页面完成加载和渲染，浏览器会关闭与服务器的TCP连接。如果页面上存在其他资源（如图片、脚本等），则浏览器可能会继续发起额外的HTTP请求来获取这些资源。</li></ol>`,79),h=[r];function n(p,d,T,k,c,P){return l(),a("div",null,h)}const E=i(o,[["render",n]]);export{S as __pageData,E as default};
